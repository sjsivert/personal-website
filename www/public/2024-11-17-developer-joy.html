<!DOCTYPE html>
<html lang="en">
  <head>
    <script
      src="https://cdn.counter.dev/script.js"
      data-id="5ae6cc8b-bfcc-4cbe-8afb-79bfad8ed1e7"
      data-utcoffset="1"
    ></script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="date" content="2024-11-17 00:34:00 +0800" />
    <title>Developer Joy</title>
    <style>
      :root {
        --color-bg: #1a1a1a;
        --color-text: #cccccc;
        --color-heading: #ffffff;
        --color-link: #4f9fff;
        --color-meta: #888888;
        --font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
      }

      body {
        margin: 0;
        padding: 0;
        font-family: var(--font-family);
        background-color: var(--color-bg);
        color: var(--color-text);
        line-height: 1.7;
      }

      main {
        max-width: 850px;
        margin: 3rem auto;
        padding: 0 1.5rem;
      }

      h1 {
        font-size: 2.5rem;
        color: var(--color-heading);
        margin: 0 0 1.5rem;
        font-weight: 600;
      }

      h2 {
        font-size: 2rem;
        color: var(--color-heading);
        margin: 2.5rem 0 1rem;
      }

      p {
        margin: 1.2rem 0;
      }

      .meta {
        color: var(--color-meta);
        font-size: 0.95rem;
        margin-bottom: 2.5rem;
      }

      img {
        max-width: 100%;
        margin: 1.5rem 0;
      }

      a {
        color: var(--color-link);
        text-decoration: none;
      }

      a:hover {
        text-decoration: underline;
      }

      blockquote {
        border-left: 5px solid #404040;
        margin: 1.5rem 0;
        padding: 0.5rem 1rem;
        color: #909090;
        font-style: italic;
      }

      .contents-button {
        display: inline-block;
        padding: 0.5rem 1rem;
        border: 1px solid #444;
        border-radius: 6px;
        color: var(--color-text);
        margin: 1rem 0;
      }

      code {
        font-family: Monaco, Consolas, monospace;
        background: #2a2a2a;
        padding: 0.2em 0.4em;
        border-radius: 3px;
        font-size: 0.9em;
      }

      .read-time {
        float: right;
        color: var(--color-meta);
      }

      @media (max-width: 600px) {
        h1 {
          font-size: 2rem;
        }
        main {
          margin: 2rem auto;
        }
      }

      .back-button {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--color-meta);
        margin-bottom: 2rem;
        transition: color 0.2s;
      }
      .back-button:hover {
        color: var(--color-text);
      }
      .back-button svg {
        width: 1.2em;
        height: 1.2em;
      }
    </style>
  </head>
  <body>
    <main>
      <a href="../index.html" class="back-button">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M10 19l-7-7m0 0l7-7m-7 7h18"
          />
        </svg>
        Back to Home
      </a>
      <article>
        <h1>Developer Joy</h1>
        <div class="meta">
          2024-11-17 00:34:00 +0800 • Sindre J.I Sivertsen
          <span class="read-time"> min read</span>
        </div>

        <p>In 2023, I attended a talk by Sven Peters from Atlassian
        titled <em>“Developer Joy - How Great Teams Get Sh%*t Done”</em>
        (<a href="https://www.youtube.com/watch?v=0wEmyhp6zK4">It’s a
        fantastic talk—you should check it out</a>). Developer
        productivity, according to Atlassian, is best measured through
        ‘developer joy.’ If organizations want to boost productivity in
        their engineering teams, their focus should be on fostering
        developer joy.</p>
        <p>As a developer, I love the sound of this. At first glance, it
        sounds like the best productivity strategy might involve
        management buying everyone pizza, installing a foosball table,
        and setting up emoji feedback buttons by the office exit—like
        the ones at airport security. I mean, it couldn’t hurt, right?
        But, unfortunately for my dreams of endless pizza, that’s not
        what Atlassian meant.</p>
        <p>Atlassian defines developer joy through three simple pillars:
        dev quality, dev progress, and dev value.</p>
        <ul>
        <li><strong>Dev quality:</strong> If I feel the code I’m writing
        is clean, well-crafted, and of high quality, then I’m scoring
        high on dev quality.</li>
        <li><strong>Dev progress:</strong> If the process of taking a
        task from the board to production is smooth and free of
        blockers, the team scores high on dev progress.</li>
        <li><strong>Dev value:</strong> If my work feels meaningful and
        valuable to others, it scores high on dev value.</li>
        </ul>
        <p>In other words, developers thrive on feeling productive. If
        an organization focuses on improving developer experience,
        enhancing tooling, and reducing friction, developers will
        naturally become more productive.</p>
        <p>While this interpretation sadly doesn’t include a foosball
        table, I still love it. Since the conference, I’ve thought a lot
        about the topic, and I’ve realized that for me personally,
        <em>short feedback loops</em> are a key component for a high
        <strong>dev progress</strong> score. Sven talked about dev
        progress in the context of big team processes. That is indeed
        important, but the idea can, and should be applied to all parts
        of software development.</p>
        <p>Software development is all about iteration and feedback
        loops. A feedback loop measures how long it takes to get
        confirmation on whether your latest work is on the right track
        or headed for a detour. The smaller the feedback loop, the
        faster you can iterate, keeping you firmly in the flow. And as
        developers, we know that maximizing time in the flow state is
        key.</p>
        <p>Slow feedback loops, on the other hand, range from mildly
        frustrating to downright exhausting. At best, they drain your
        energy; at worst, they can lead to months of wasted effort and
        man-hours.</p>
        <p>In this article, I’ll dive into different types of feedback
        loops and explore ways to shrink them down as much as
        possible.</p>
        <h2 id="the-code">The code</h2>
        <p>Writing code is an iterative process, and let’s be
        honest—most of the time, when you stop typing, you’re greeted by
        the dreaded red line. Over the years, though, I’ve come to
        appreciate that red line as the best feedback buddy a developer
        could ask for. Instantly, you know if what you’ve written is
        spot-on or wildly off. If it’s not correct, you even get a handy
        description of what went wrong (along with a gentle nudge to fix
        it).</p>
        <p>This red line is all thanks to static code analysis, handled
        by the compiler. For compiled languages, like C# with the Roslyn
        compiler, static analysis is part of the compiler’s job,
        catching issues early. How much help you get from your code
        editor depends a lot on your language of choice. Strongly typed
        languages like C# and TypeScript offer tons of insights on
        potential issues before a single line executes, while dynamic
        languages like Python and JavaScript can mostly catch errors
        related to incorrect syntax.</p>
        <p>Some languages can tighten up the feedback loops by
        disallowing null pointers—one of Kotlin’s big advantages over
        Java. Or consider enforced error handling in languages like Rust
        and Go, where every function call requires a plan for failure
        before your code is considered valid. Generally, the stricter
        the compiler, the more errors can be avoided at runtime,
        resulting in a shorter feedback loop. After all, it’s far better
        to handle an edge case today than track down a bug in production
        a month from now.</p>
        <p>Unfortunately, thanks to the famous <a
        href="https://brilliant.org/wiki/halting-problem/">halting
        problem</a>, some issues are beyond a compiler’s reach. That
        brings us to the next feedback loop: running the code
        itself.</p>
        <p>Here, compile time is an obvious bottleneck. When you’re
        working on something that demands lots of small tweaks—like
        CSS—even a compile time over two seconds can test the patience
        of the most zen programmers after a while.</p>
        <p>There are ways to speed up compile times depending on the
        language. In JavaScript, you can swap out webpack with Bun or
        Turbopack. Iteratively compiled languages like C# and Java can
        benefit from shared build cache servers. Another option to speed
        things up is by doing <em>less</em> static analysis (but we’re
        not quite that desperate!). Another quality-of-life boost is
        <em>live code updates</em>, where changes are instantly
        reflected without needing a full recompile.</p>
        <p>When compile times start dragging on long enough for
        developers to grow gray beards waiting, the go-to solution is
        often to split a monolithic codebase into multiple,
        independently deployable services. This can give a shorter
        feedback loop initially, but it may eventually cost you with a
        longer feedback loop <a
        href="https://www.youtube.com/watch?v=LcJKxPXYudE">in the long
        run</a>.</p>
        <p>But let’s say you’re writing a new REST endpoint for your
        large monolith in a language that’s not Go. You’re in a
        strongly-typed language, like C#, but with a hefty 10-second
        compile time. Every time you want to run the code, you’re stuck
        waiting, so you pop over to Postman and start spamming the send
        request button just to pass the time. This feedback loop drags
        on, and after a while, it’s downright exhausting.</p>
        <p>A simple way to tighten this loop? Write a test. Unit tests
        in iteratively compiled languages can run much quicker than the
        program itself, since the compiler only needs to compile the
        test itself and any assemblies it relies on. Plus, you won’t be
        flipping back and forth between your IDE and Postman.</p>
        <p>Writing a test early on is an investment that pays off both
        short-term, while you’re building the code, and long-term, when
        someone else (or future you) makes changes. For me, putting in a
        bit of effort upfront to keep the feedback loop fast is always
        worth it!</p>
        <hr />
        <h2 id="the-pull-request">The pull request</h2>
        <p>You (think) you’re done writing some code, and it’s time to
        share it with the world—or at least with the team. For a
        software developer, that means creating a pull request and
        bracing yourself for code review. But before you want to request
        a review from that senior developer that always catch you in
        doing silly mistakes you wished you found yourself before
        requesting a review, you should wait for the required pipelines
        to go green. The art of writing speedy pipelines deserves a post
        of it’s own, but in short:</p>
        <ul>
        <li>Don’t do steps in the order that feels natural, eg, lint,
        build, unit tests, e2e tests. Run the pipeline in order of
        dependency, and optimize the pipeline to fail fast. If that
        means running the e2e test right after the build step, do
        it.</li>
        <li>Use caching as much as possible.</li>
        <li>Run things in parallel when possible.</li>
        <li>A pipeline that runs longer than 10 minutes is too long. I
        recommend this NDC talk on this topic : <a
        href="https://www.youtube.com/watch?v=OonABHdHD2I&amp;t=1214s">CI/CD
        Patterns and antipatterns</a>.</li>
        </ul>
        <p>Unlike the solo speed of coding, code review slows things
        down because it depends on others. Keeping a snappy feedback
        loop in the code review process is all about team culture: the
        team should prioritize pull requests above <em>almost</em>
        everything else. After all, the main goal of a team is to
        deliver value to users or the company through the code they
        create. And a pull request represents code that’s closer to the
        finish line than whatever you’re currently working on. So, the
        fastest way you can add value is actually by reviewing your
        co-worker’s code—giving them the green light so they can ship
        it!</p>
        <p>There are steps to ease the pain of context switching away
        from what you are currently doing, over to running and reviewing
        someones code. I once worked on a team developing a mobile app
        with React Native, and every time we fired up the iOS simulator,
        we faced a dreaded two-step authentication before even getting
        to the home screen. It was a step we went through maybe three
        times a day, tops. But the mental toll it took was huge. I
        noticed my teammates were more reluctant to do pull requests,
        and honestly, I started skipping the process of running the code
        on my device just to avoid the login.</p>
        <p>Then, one day, a coworker added a simple if-statement to
        fetch credentials from an .env file whenever we ran the code in
        dev mode. He probably spent a day on it, tops. Now, you could
        argue that the time he spent didn’t really balance out the time
        we wasted manually logging in each time. But, let me tell you,
        this autologin feature was a game-changer. With that login
        barrier gone, we could switch branches and collaborate way more
        freely. It was easier to run each other’s code, which meant code
        quality went up, bugs got caught earlier, and everyone was
        happier (and probably a little more sane).</p>
        <p>Another example was when our team was building a Microsoft
        Teams bot. The setup process for our local dev environment was…
        well, let’s just say it was a ritual in itself:</p>
        <ol type="1">
        <li>Fire up a reverse proxy tunnel with devtunnel.</li>
        <li>Grab the reverse proxy URL and update the Teams bot
        configuration in Azure to point to that specific URL.</li>
        <li>Update not one, but two separate
        <code>launchSettings.json</code> files locally.</li>
        <li>Modify a database row (also locally, of course).</li>
        </ol>
        <p>Now, whenever we switched gears from the Teams bot to backend
        business, we had to backtrack through every single one of these
        steps. For weeks, we’d repeat this four-step dance manually,
        over and over, before it finally dawned on me—<em>this could be
        automated with a simple bash script</em>. Half a day later, I
        had a script that would’ve saved us all so much time and
        probably should have been created ages ago.</p>
        <p>Streamlining code reviews should be a top priority for any
        team. Small actions can make a huge difference. For example,
        including a screenshot or video in a pull request can quickly
        give reviewers the context they need. And for any UI changes,
        nothing beats a temporary preview of the website—pure magic for
        a reviewer! Hosting platforms like Vercel and Netlify, and Expo
        have nailed this with their instant, no-setup preview feature.
        It’s practically a life-saver and likely one of the big reasons
        they’re so popular in the world of SaaS hosting. A small feature
        GitHub just released is a plugin for VS Code that lets you do
        pull requests from within VS Code. A small feature, but I
        personally found it gave huge value.</p>
        <p>There are many more feedback loops in the life of a software
        developer. But this post is getting long, and I don’t have
        enough experiences under my belt yet to comment on them all.
        Each example I have talked about reinforces one central truth:
        shorter feedback loops lead to happier, more productive
        developers.</p>
        <p>When feedback comes quickly, you stay in the flow, maintain
        momentum, and feel a sense of progress. It’s no surprise that
        “developer joy” hinges on improving these loops—making tools
        faster, processes smoother, and collaboration easier.</p>
        <p>Shortening feedback loops isn’t just about boosting
        individual productivity; it’s about creating an environment
        where teams can deliver value effectively. Whether it’s
        automating the small stuff, streamlining processes, or
        prioritizing code reviews, every improvement feeds into a
        culture of efficiency and satisfaction. I feel fortunate to work
        at a company that values developer joy and gives us the time to
        invest in it. I know many friends in the industry who aren’t as
        lucky, and it makes me appreciate this focus even more.</p>
        <p>So, as you continue your work as a developer, ask yourself:
        where can feedback loops be shortened? Where can friction be
        reduced? Every small change adds up, and the payoff—both for you
        and your team—will be well worth the effort.</p>
        <hr />
      </article>
    </main>
  </body>
</html>
